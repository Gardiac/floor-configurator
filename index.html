<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Floor Configurator — v4</title>
  <style>
    :root{ --bg:#f6f3ef; --text:#2b241e; --muted:#6f5f52; --panel:#fffdf9; --accent:#b87333; --line:#e6ded5; --shadow:0 10px 24px rgba(45,33,23,.08); }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    header{position:sticky;top:0;z-index:10;display:flex;gap:12px;align-items:center;padding:12px 14px;border-bottom:1px solid var(--line);background:#fff}
    main{display:grid;grid-template-columns:320px 1fr;gap:14px;padding:14px}
    .panel{background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow);padding:12px}
    #canvasWrap{position:relative;height:calc(100vh - 150px);min-height:360px;background:#fff;border-radius:16px;border:1px solid var(--line);overflow:hidden}
    canvas{display:block;width:100%;height:100%}
    #glCanvas{position:absolute;inset:0;background:transparent} /* IMPORTANT: transparent overlay */
    #roomCanvas{position:absolute;inset:0}
    .handle{position:absolute;width:14px;height:14px;border-radius:50%;background:var(--accent);border:2px solid #fff;transform:translate(-50%,-50%);cursor:grab}
    #toast{position:fixed;right:16px;bottom:16px;padding:10px 12px;border:1px solid var(--line);border-radius:12px;background:#fff;box-shadow:var(--shadow);color:#6f5f52;font-size:12px;max-width:50ch;display:none}
    #debug{position:fixed;left:16px;bottom:16px;padding:8px 10px;border:1px solid var(--line);border-radius:12px;background:#fff;box-shadow:var(--shadow);color:#7d5a3d;font-size:12px;max-width:60ch;display:none;white-space:pre-wrap}
    .row{display:flex;gap:8px;align-items:center;margin:8px 0}
    .btn{appearance:none;cursor:pointer;border:1px solid #d9c9b8;background:#fff;color:#5a3f2c;padding:9px 11px;border-radius:10px;font-weight:700}
  </style>
</head>
<body>
  <header><b>AI Floor Configurator — v4</b></header>
  <main>
    <section class="panel">
      <div class="row"><input id="roomFile" type="file" accept="image/png,image/jpeg,image/webp,image/gif"></div>
      <div class="row"><input id="texFile" type="file" accept="image/png,image/jpeg,image/webp,image/gif"></div>
      <div class="row"><button class="btn" id="btnAI">Detect & Replace (AI)</button><button class="btn" id="btnSelf">Self‑test</button></div>
    </section>
    <section class="panel">
      <div id="canvasWrap">
        <canvas id="roomCanvas"></canvas>
        <canvas id="glCanvas"></canvas>
        <div class="handle" id="h0" style="left: 20%; top: 68%"></div>
        <div class="handle" id="h1" style="left: 80%; top: 68%"></div>
        <div class="handle" id="h2" style="left: 76%; top: 92%"></div>
        <div class="handle" id="h3" style="left: 24%; top: 92%"></div>
      </div>
    </section>
  </main>
  <div id="toast"></div><div id="debug"></div>
  <script>
  (function(){
    const $ = id=>document.getElementById(id);
    const toast=$('toast'); const debug=$('debug');
    const wrap=$('canvasWrap'); const rc=$('roomCanvas'); const gc=$('glCanvas'); const rctx=rc.getContext('2d');
    const state={ roomImage:null, plankTexture:null, quad:[{x:.2,y:.68},{x:.8,y:.68},{x:.76,y:.92},{x:.24,y:.92}], roomRect:{x:0,y:0,w:0,h:0} };
    function tip(m){ toast.textContent=m; toast.style.display='block'; setTimeout(()=>toast.style.display='none',2500); }
    function log(m){ if(m){debug.textContent=m;debug.style.display='block';}else{debug.textContent='';debug.style.display='none';} }

    function resize(){
      const r = wrap.getBoundingClientRect();
      rc.width=r.width; rc.height=r.height; gc.width=r.width; gc.height=r.height;
      drawRoom(); if(gl){ gl.viewport(0,0,gc.width,gc.height); } render();
    }
    window.addEventListener('resize', resize);

    function drawRoom(){
      const w=rc.width,h=rc.height; rctx.clearRect(0,0,w,h);
      if(!state.roomImage) return;
      const iw=state.roomImage.width, ih=state.roomImage.height;
      const s=Math.max(w/iw,h/ih); const dw=iw*s, dh=ih*s; const dx=(w-dw)/2, dy=(h-dh)/2;
      state.roomRect={x:dx,y:dy,w:dw,h:dh}; rctx.drawImage(state.roomImage,dx,dy,dw,dh);
    }

    function loadImage(file){
      return new Promise((res,rej)=>{
        const reader=new FileReader(); reader.onerror=()=>rej(new Error('read fail'));
        reader.onload=()=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>rej(new Error('decode fail')); img.src=reader.result; };
        reader.readAsDataURL(file);
      });
    }

    // IMPORTANT: request alpha:true for transparent clear color
    const gl = gc.getContext('webgl', { alpha:true, premultipliedAlpha:true, antialias:true, preserveDrawingBuffer:false });
    if(!gl){ alert('WebGL not available'); return; }

    function sh(t,s){ const o=gl.createShader(t); gl.shaderSource(o,s); gl.compileShader(o); if(!gl.getShaderParameter(o,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(o)); return o; }
    const vsrc=`attribute vec2 a_pos;attribute vec2 a_uv;varying vec2 v_uv;uniform vec2 u_res;void main(){vec2 o=a_pos/u_res*2.0-1.0;gl_Position=vec4(o*vec2(1.0,-1.0),0.0,1.0);v_uv=a_uv;}`;
    const fsrc=`precision mediump float;varying vec2 v_uv;uniform sampler2D u_tex;void main(){gl_FragColor=texture2D(u_tex,v_uv);} `;
    const prog=gl.createProgram(); gl.attachShader(prog,sh(gl.VERTEX_SHADER,vsrc)); gl.attachShader(prog,sh(gl.FRAGMENT_SHADER,fsrc)); gl.linkProgram(prog); if(!gl.getProgramParameter(prog,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog)); gl.useProgram(prog);
    const a_pos=gl.getAttribLocation(prog,'a_pos'); const a_uv=gl.getAttribLocation(prog,'a_uv'); const u_res=gl.getUniformLocation(prog,'u_res'); gl.uniform2f(u_res,gc.width,gc.height);

    // Transparent clear so room photo is visible underneath
    gl.clearColor(0,0,0,0);

    const vbo=gl.createBuffer(), tbo=gl.createBuffer();
    function textureFromImage(img){
      const tex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,tex);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.REPEAT); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.REPEAT);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,0); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
      return tex;
    }

    function buildMesh(){
      const w=gc.width,h=gc.height,q=state.quad.map(p=>({x:p.x*w,y:p.y*h}));
      const lerp=(a,b,t)=>a+(b-a)*t, ip=(u,v)=>({x:lerp(lerp(q[0].x,q[1].x,u),lerp(q[3].x,q[2].x,u),v),y:lerp(lerp(q[0].y,q[1].y,u),lerp(q[3].y,q[2].y,u),v)});
      const verts=[],uvs=[]; const cols=64,rows=64;
      for(let y=0;y<rows;y++){ const v0=y/rows,v1=(y+1)/rows;
        for(let x=0;x<cols;x++){ const u0=x/cols,u1=(x+1)/cols;
          const p00=ip(u0,v0),p10=ip(u1,v0),p11=ip(u1,v1),p01=ip(u0,v1);
          verts.push(p00.x,p00.y,p10.x,p10.y,p11.x,p11.y,  p00.x,p00.y,p11.x,p11.y,p01.x,p01.y);
          uvs.push(u0,v0,u1,v0,u1,v1,  u0,v0,u1,v1,u0,v1);
        }
      }
      return {verts:new Float32Array(verts),uvs:new Float32Array(uvs)};
    }
    let mesh=null;
    function render(){
      gl.clear(gl.COLOR_BUFFER_BIT);
      if(!state.plankTexture) return;
      if(!mesh) mesh=buildMesh();
      gl.useProgram(prog); gl.uniform2f(u_res,gc.width,gc.height);
      gl.bindBuffer(gl.ARRAY_BUFFER,vbo); gl.bufferData(gl.ARRAY_BUFFER,mesh.verts,gl.DYNAMIC_DRAW); gl.enableVertexAttribArray(a_pos); gl.vertexAttribPointer(a_pos,2,gl.FLOAT,false,0,0);
      gl.bindBuffer(gl.ARRAY_BUFFER,tbo); gl.bufferData(gl.ARRAY_BUFFER,mesh.uvs,gl.DYNAMIC_DRAW); gl.enableVertexAttribArray(a_uv); gl.vertexAttribPointer(a_uv,2,gl.FLOAT,false,0,0);
      gl.drawArrays(gl.TRIANGLES,0,mesh.verts.length/2);
    }

    $('roomFile').addEventListener('change', async e=>{
      const f=e.target.files?.[0]; if(!f) return;
      try{ const img=await loadImage(f); state.roomImage=img; drawRoom(); tip('Room loaded'); }catch(err){ log('Room load error: '+(err?.message||err)); }
    });
    $('texFile').addEventListener('change', async e=>{
      const f=e.target.files?.[0]; if(!f) return;
      try{ const img=await loadImage(f); state.plankTexture=textureFromImage(img); mesh=null; render(); tip('Texture loaded'); }catch(err){ log('Texture load error: '+(err?.message||err)); }
    });

    $('btnSelf').addEventListener('click', ()=>{
      const c=document.createElement('canvas'); c.width=1024; c.height=768; const cx=c.getContext('2d');
      cx.fillStyle='#e9edf7'; cx.fillRect(0,0,1024,480); cx.fillStyle='#b99774'; cx.fillRect(0,480,1024,288);
      const img=new Image(); img.onload=()=>{ state.roomImage=img; drawRoom(); tip('Self-test drawn'); }; img.src=c.toDataURL('image/png');
    });

    function ensureReady(){ resize(); log('Boot ✓\nWebGL alpha overlay enabled'); }
    if (document.readyState!=='loading') setTimeout(ensureReady,0); else window.addEventListener('DOMContentLoaded',ensureReady);
  })();
  </script>
</body>
</html>
