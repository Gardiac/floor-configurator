<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Floor Configurator — v4</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500;700&family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #f6f3ef;
      --text: #2b241e;
      --muted:#6f5f52;
      --panel:#fffdf9;
      --accent:#b87333;
      --accent-2:#6d4c41;
      --line:#e6ded5;
      --shadow: 0 10px 24px rgba(45, 33, 23, 0.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family:Poppins,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    header{position:sticky;top:0;z-index:10;display:flex;align-items:center;gap:18px;padding:16px 18px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,#fff,#f4eee6);}
    header h1{font-size:18px;margin:0;font-weight:700;color:var(--accent-2);letter-spacing:.2px}
    header .tag{padding:6px 10px;border-radius:999px;background:#fdebd2;border:1px solid #f3d6ad;color:#7a4e1c;font-weight:600}
    main{display:grid;grid-template-columns:340px 1fr;gap:18px;padding:18px;}
    .panel{background:var(--panel);border:1px solid var(--line);border-radius:18px;box-shadow:var(--shadow);padding:14px}
    .panel h2{margin:6px 0 12px;font-size:13px;color:var(--muted);text-transform:uppercase;letter-spacing:.12em}
    .row{display:flex;gap:10px;align-items:center;margin:8px 0}
    .row > *{flex:1}
    label{font-size:12px;color:var(--muted)}
    input[type=file],input[type=url],input[type=text]{width:100%;padding:9px 10px;border:1px solid var(--line);border-radius:10px;background:#fff;color:var(--text)}
    input[type=range]{width:100%}
    .seg{display:flex;gap:8px}
    .btn{appearance:none;cursor:pointer;border:1px solid #d9c9b8;background:linear-gradient(180deg,#fff,#f6efe6);color:#5a3f2c;padding:10px 12px;border-radius:12px;font-weight:700;box-shadow:0 2px 0 #e8d8c8}
    .btn:hover{filter:brightness(1.03)}
    .btn.primary{background:linear-gradient(180deg,#e7a563,#d68a48);color:#fff;border-color:#c77c3a;box-shadow:0 2px 0 #b46e34}
    #canvasWrap{position:relative;height:calc(100vh - 170px);min-height:360px;background:#fff;border-radius:18px;border:1px solid var(--line);overflow:hidden}
    canvas{display:block;width:100%;height:100%}
    #roomCanvas{position:absolute;inset:0}
    #glCanvas{position:absolute;inset:0}
    .handle{position:absolute;width:14px;height:14px;border-radius:50%;background:var(--accent);border:2px solid #fff;box-shadow:0 1px 6px rgba(0,0,0,.25);transform:translate(-50%,-50%);cursor:grab}
    #toast{position:fixed;right:16px;bottom:16px;padding:10px 12px;border:1px solid var(--line);border-radius:12px;background:#fff;box-shadow:var(--shadow);color:var(--muted);font-size:12px;max-width:50ch;display:none}
    #debug{position:fixed;left:16px;bottom:16px;padding:8px 10px;border:1px solid var(--line);border-radius:12px;background:#fff;box-shadow:var(--shadow);color:#7d5a3d;font-size:12px;max-width:60ch;display:none;white-space:pre-wrap}
    .split{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .small{font-size:12px;color:var(--muted)}
    .pill{padding:6px 8px;border-radius:999px;background:#efe6dd;color:#7e5a3c;border:1px solid #e1d4c8;font-weight:600;font-size:11px}
    .hero{display:flex;align-items:center;gap:10px;margin-bottom:8px}
    .hero b{font-family:Merriweather,serif;font-weight:700;color:#3e2723}
    .spinner{position:absolute;inset:0;display:none;place-items:center;background:rgba(255,255,255,.6)}
    .spinner .dot{width:10px;height:10px;border-radius:50%;background:var(--accent);animation:b 1s infinite alternate}
    .spinner .dot:nth-child(2){animation-delay:.15s}
    .spinner .dot:nth-child(3){animation-delay:.3s}
    @keyframes b{to{transform:translateY(-6px);opacity:.6}}
  </style>
</head>
<body>
  <header>
    <h1>🪵 AI Floor Configurator — v4</h1>
    <span class="tag">Vision + Tool Calls</span>
    <span class="small">Theme vibe: Woodworking Carpenter</span>
  </header>

  <main>
    <section class="panel" id="left">
      <div class="hero">
        <b>Bring your room photo</b>
        <span class="pill">No design skills needed</span>
      </div>

      <h2>Assets</h2>
      <div class="row"><label>Room photo</label><input id="roomFile" type="file" accept="image/png,image/jpeg,image/webp,image/gif" /></div>
      <div class="row split">
        <div><label>Plank texture (file)</label><input id="texFile" type="file" accept="image/png,image/jpeg,image/webp,image/gif" /></div>
        <div><label>Plank texture (URL)</label><input id="texUrl" type="url" placeholder="https://…/plank.jpg" /></div>
      </div>
      <div class="row">
        <button class="btn" id="btnLoadURL">Load URL</button>
        <button class="btn" id="btnAuto">Auto-detect (basic)</button>
      </div>

      <h2>Ask AI</h2>
      <div class="row"><input id="prompt" type="text" placeholder="e.g., Replace the floor with the texture URL and make boards horizontal, rotate 2°" /></div>
      <div class="row"><button class="btn primary" id="btnAI">Detect & Replace (AI)</button></div>
      <div class="small">The AI looks at your photo and returns a floor polygon + tiling settings. Keys stay on your server.</div>

      <h2>Layout</h2>
      <div class="row seg">
        <button class="btn" id="btnHorizontal">Horizontal</button>
        <button class="btn" id="btnVertical">Vertical</button>
      </div>
      <div class="row"><label>Scale <span id="scaleVal" class="small">1.00</span></label><input id="scale" type="range" min="0.2" max="4" value="1" step="0.01" /></div>
      <div class="row"><label>Rotation <span id="rotVal" class="small">0°</span></label><input id="rotation" type="range" min="-90" max="90" value="0" step="0.5" /></div>
      <div class="row"><label>Variation <span id="rndVal" class="small">0.25</span></label><input id="randomness" type="range" min="0" max="1" value="0.25" step="0.01" /></div>
      <div class="row"><label>Groove width <span id="grooveVal" class="small">0.015</span></label><input id="groove" type="range" min="0" max="0.05" value="0.015" step="0.001" /></div>
      <div class="row"><label>Light strength <span id="lightVal" class="small">0.65</span></label><input id="light" type="range" min="0" max="1" value="0.65" step="0.01" /></div>

      <h2>Export</h2>
      <div class="row"><button class="btn" id="btnExport">Download PNG</button></div>
      <div class="row"><button class="btn" id="btnSelfTest">Self-test (draw demo)</button></div>
      <div class="small">Tip: Drag the four dots over the floor if you want to fine-tune the AI result.</div>
    </section>

    <section class="panel" id="center">
      <div id="canvasWrap">
        <div class="spinner" id="busy"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
        <canvas id="roomCanvas"></canvas>
        <canvas id="glCanvas"></canvas>
        <div class="handle" id="h0" style="left: 20%; top: 68%"></div>
        <div class="handle" id="h1" style="left: 80%; top: 68%"></div>
        <div class="handle" id="h2" style="left: 76%; top: 92%"></div>
        <div class="handle" id="h3" style="left: 24%; top: 92%"></div>
      </div>
    </section>
  </main>

  <div id="toast"></div>
  <div id="debug"></div>

  <script>
  (function(){
    const $ = (id)=> document.getElementById(id);
    const toast = $('toast');
    const debugEl = $('debug');
    function tip(msg){ toast.textContent = msg; toast.style.display = 'block'; setTimeout(()=> toast.style.display='none', 3000); }
    function logDebug(msg){ if(!debugEl) return; if(msg){ debugEl.textContent = msg; debugEl.style.display='block'; } else { debugEl.textContent=''; debugEl.style.display='none'; } }
    function busy(on){ $('busy').style.display = on ? 'grid' : 'none'; }

    const roomFile = $('roomFile');
    const texFile  = $('texFile');
    const texUrl   = $('texUrl');
    const btnLoadURL = $('btnLoadURL');
    const btnH = $('btnHorizontal');
    const btnV = $('btnVertical');
    const btnAuto = $('btnAuto');
    const btnAI = $('btnAI');
    const scaleEl = $('scale');
    const rotationEl = $('rotation');
    const randomnessEl = $('randomness');
    const grooveEl = $('groove');
    const lightEl = $('light');
    const scaleVal=$('scaleVal'), rotVal=$('rotVal'), rndVal=$('rndVal'), grooveVal=$('grooveVal'), lightVal=$('lightVal');
    const btnExport = $('btnExport');

    const wrap = $('canvasWrap');
    const roomCanvas = $('roomCanvas');
    const glCanvas = $('glCanvas');
    const rctx = roomCanvas.getContext('2d');

    const state = {
      roomImage: null,
      plankTexture: null,
      lightTexture: null,
      orientation: 'horizontal',
      scale: 1,
      rotationDeg: 0,
      randomness: 0.25,
      groove: 0.015,
      roomRect: { x:0, y:0, w:0, h:0 },
      lightStrength: 0.65,
      quad: [ {x:0.20,y:0.68}, {x:0.80,y:0.68}, {x:0.76,y:0.92}, {x:0.24,y:0.92} ],
      currentTextureUrl: ''
    };

    function resize(){
      const r = wrap.getBoundingClientRect();
      roomCanvas.width = r.width; roomCanvas.height = r.height;
      glCanvas.width = r.width; glCanvas.height = r.height;
      drawRoom();
      if (gl) gl.viewport(0,0,glCanvas.width, glCanvas.height);
      updateMesh(); render(); syncHandles();
    }
    window.addEventListener('resize', resize);

    function drawRoom(){
      const cw = roomCanvas.width, ch = roomCanvas.height;
      rctx.clearRect(0,0,cw,ch);
      if(!state.roomImage) return;
      const iw = state.roomImage.width, ih = state.roomImage.height;
      const s = Math.max(cw/iw, ch/ih);
      const w = iw*s, h = ih*s; const x=(cw-w)/2, y=(ch-h)/2;
      state.roomRect = { x, y, w, h };
      rctx.drawImage(state.roomImage, x, y, w, h);
      buildLightTexture();
    }

    function loadImage(file){
      return new Promise((resolve,reject)=>{
        if (!file) return reject(new Error('No file provided'));
        const isHeic = /heic|heif/i.test(file.type) || /\.hei[cf]$/i.test(file.name||'');
        if (isHeic) return reject(new Error('HEIC/HEIF images are not supported by your browser. Please convert to JPG/PNG/WEBP.'));
        const type = file.type || '';
        if (!/^image\//.test(type)) return reject(new Error('Please choose an image file (JPG/PNG/WEBP).'));
        const reader = new FileReader();
        reader.onerror = ()=> reject(new Error('Could not read file.'));
        reader.onload = ()=>{
          const img = new Image();
          img.onload = ()=> resolve(img);
          img.onerror = ()=> reject(new Error('Unsupported image format. Try JPG/PNG/WEBP.'));
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      });
    }
    function loadImageURL(url){
      return new Promise((resolve,reject)=>{
        const img = new Image(); img.crossOrigin='anonymous';
        img.onload = ()=> resolve(img);
        img.onerror = (e)=> reject(e);
        img.src = url;
      });
    }

    const gl = glCanvas.getContext('webgl');
    if(!gl){ logDebug('WebGL not available in this browser/tab. Try Chrome/Edge with hardware acceleration.'); alert('WebGL not available'); return; }

    function compileShader(type, src){
      const sh = gl.createShader(type); gl.shaderSource(sh, src); gl.compileShader(sh);
      if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(sh));
      return sh;
    }

    const vsrc = `
      attribute vec2 a_pos;
      attribute vec2 a_uv;
      varying vec2 v_uv;
      varying vec2 v_posPx;
      uniform vec2 u_resolution;
      void main(){
        vec2 zeroToOne = a_pos / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clip = zeroToTwo - 1.0;
        gl_Position = vec4(clip * vec2(1.0, -1.0), 0.0, 1.0);
        v_uv = a_uv;
        v_posPx = a_pos;
      }
    `;

    const fsrc = `
      precision mediump float;
      varying vec2 v_uv;
      varying vec2 v_posPx;
      uniform sampler2D u_tex;
      uniform sampler2D u_lightTex;
      uniform vec4 u_roomRect;
      uniform float u_lightStrength;
      uniform float u_noiseAmp;
      uniform float u_groove;

      float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123); }

      void main(){
        vec4 wood = texture2D(u_tex, v_uv);

        float v2 = fract(v_uv.y);
        float groove = step(v2, u_groove) + step(1.0-u_groove, v2);
        float grooveDarken = mix(1.0, 0.65, groove);

        float n = hash(floor(v_uv*vec2(7.0,3.0)));
        float tint = 1.0 + (n-0.5)*u_noiseAmp;

        vec2 uvRoom = (v_posPx - u_roomRect.xy) / u_roomRect.zw;
        float light = 1.0;
        if (uvRoom.x>=0.0 && uvRoom.x<=1.0 && uvRoom.y>=0.0 && uvRoom.y<=1.0) {
          vec3 rc = texture2D(u_lightTex, uvRoom).rgb;
          float lum = dot(rc, vec3(0.299,0.587,0.114));
          light = mix(1.0, lum*1.1 + 0.45, u_lightStrength);
        }

        vec3 finalCol = wood.rgb * grooveDarken * tint * light;
        gl_FragColor = vec4(finalCol, 1.0);
      }
    `;

    const prog = gl.createProgram();
    gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, vsrc));
    gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, fsrc));
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
    gl.useProgram(prog);

    const a_pos = gl.getAttribLocation(prog, 'a_pos');
    const a_uv  = gl.getAttribLocation(prog, 'a_uv');
    const u_resolution    = gl.getUniformLocation(prog, 'u_resolution');
    const u_tex           = gl.getUniformLocation(prog, 'u_tex');
    const u_lightTex      = gl.getUniformLocation(prog, 'u_lightTex');
    const u_roomRect      = gl.getUniformLocation(prog, 'u_roomRect');
    const u_lightStrength = gl.getUniformLocation(prog, 'u_lightStrength');
    const u_noiseAmp      = gl.getUniformLocation(prog, 'u_noiseAmp');
    const u_groove        = gl.getUniformLocation(prog, 'u_groove');
    gl.uniform1i(u_tex, 0);
    gl.uniform1i(u_lightTex, 1);

    const vbo = gl.createBuffer();
    const tbo = gl.createBuffer();

    function toPOT(n){ return Math.pow(2, Math.max(0, Math.ceil(Math.log2(n)))); }

    function textureFromImage(img){
      const w = toPOT(img.width), h = toPOT(img.height);
      const c = document.createElement('canvas'); c.width = w; c.height = h;
      const cx = c.getContext('2d'); cx.drawImage(img, 0, 0, w, h);
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      return tex;
    }

    function buildLightTexture(){
      if(!state.roomImage) return;
      const C = document.createElement('canvas'); C.width = 64; C.height = 64;
      const cx = C.getContext('2d');
      const iw = state.roomImage.width, ih = state.roomImage.height;
      const s = Math.max(C.width/iw, C.height/ih);
      const w = iw*s, h = ih*s; const x=(C.width-w)/2, y=(C.height-h)/2;
      cx.drawImage(state.roomImage, x, y, w, h);
      const tex = gl.createTexture();
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, C);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      state.lightTexture = tex;
      gl.activeTexture(gl.TEXTURE0);
    }

    let mesh = null;
    function buildMesh(cols=64, rows=64){
      const w = glCanvas.width, h = glCanvas.height;
      const q = state.quad.map(p=>({ x:p.x*w, y:p.y*h }));
      const lerp=(a,b,t)=> a+(b-a)*t;
      function interp(u,v){
        const topX = lerp(q[0].x, q[1].x, u), topY = lerp(q[0].y, q[1].y, u);
        const botX = lerp(q[3].x, q[2].x, u), botY = lerp(q[3].y, q[2].y, u);
        return { x: lerp(topX, botX, v), y: lerp(topY, botY, v) };
      }
      const verts=[], uvs=[];
      const s = state.scale;
      const rot = state.rotationDeg * Math.PI/180;
      const c = Math.cos(rot), sn = Math.sin(rot);
      const rotUV=(u,v)=>({u:u*c - v*sn, v:u*sn + v*c});
      const jitter = Array.from({length:rows+1}, ()=> (Math.random()-0.5)*state.randomness*2);
      for(let y=0;y<rows;y++){
        const v0 = y/rows, v1 = (y+1)/rows;
        for(let x=0;x<cols;x++){
          const u0 = x/cols, u1 = (x+1)/cols;
          const p00 = interp(u0, v0), p10 = interp(u1, v0), p11 = interp(u1, v1), p01 = interp(u0, v1);
          let b00={u:(state.orientation==='horizontal'?u0:v0), v:(state.orientation==='horizontal'?v0:u0)};
          let b10={u:(state.orientation==='horizontal'?u1:v0), v:(state.orientation==='horizontal'?v0:u1)};
          let b11={u:(state.orientation==='horizontal'?u1:v1), v:(state.orientation==='horizontal'?v1:u1)};
          let b01={u:(state.orientation==='horizontal'?u0:v1), v:(state.orientation==='horizontal'?v1:u0)};
          b00.u += jitter[y]; b10.u += jitter[y]; b01.u += jitter[y+1]; b11.u += jitter[y+1];
          const r00=rotUV(b00.u*s, b00.v*s), r10=rotUV(b10.u*s, b10.v*s), r11=rotUV(b11.u*s, b11.v*s), r01=rotUV(b01.u*s, b01.v*s);
          verts.push(p00.x,p00.y, p10.x,p10.y, p11.x,p11.y,  p00.x,p00.y, p11.x,p11.y, p01.x,p01.y);
          uvs.push(r00.u,r00.v, r10.u,r10.v, r11.u,r11.v,  r00.u,r00.v, r11.u,r11.v, r01.u,r01.v);
        }
      }
      mesh = { verts: new Float32Array(verts), uvs: new Float32Array(uvs) };
    }
    function updateMesh(){ mesh=null; buildMesh(); }

    function render(){
      gl.clearColor(1,1,1,1); gl.clear(gl.COLOR_BUFFER_BIT);
      if(!state.plankTexture) return;
      if(!mesh) buildMesh();
      gl.useProgram(prog);
      gl.uniform2f(u_resolution, glCanvas.width, glCanvas.height);
      const rw = Math.max(1.0, state.roomRect.w||1), rh = Math.max(1.0, state.roomRect.h||1);
      gl.uniform4f(u_roomRect, state.roomRect.x||0, state.roomRect.y||0, rw, rh);
      gl.uniform1f(u_lightStrength, state.lightStrength);
      gl.uniform1f(u_noiseAmp, 0.08);
      gl.uniform1f(u_groove, state.groove);

      gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.plankTexture);
      gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, state.lightTexture);

      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, mesh.verts, gl.DYNAMIC_DRAW);
      gl.enableVertexAttribArray(a_pos);
      gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, tbo);
      gl.bufferData(gl.ARRAY_BUFFER, mesh.uvs, gl.DYNAMIC_DRAW);
      gl.enableVertexAttribArray(a_uv);
      gl.vertexAttribPointer(a_uv, 2, gl.FLOAT, false, 0, 0);

      const triCount = mesh.verts.length/2/3;
      gl.drawArrays(gl.TRIANGLES, 0, triCount);
    }

    function setPlankFromImage(img){
      try{ if(state.plankTexture) gl.deleteTexture(state.plankTexture); }catch(_){ }
      state.plankTexture = textureFromImage(img);
      render();
    }
    function setPlankFromURL(url){
      loadImageURL(url).then(setPlankFromImage).catch(()=> tip('Could not load texture URL'));
    }

    function exportPNG(){
      const out = document.createElement('canvas');
      out.width = glCanvas.width; out.height = glCanvas.height;
      const oc = out.getContext('2d');
      oc.drawImage(roomCanvas, 0, 0);
      oc.drawImage(glCanvas, 0, 0);
      const url = out.toDataURL('image/png');
      const a = document.createElement('a'); a.href = url; a.download = 'floor-config.png'; a.click();
    }

    function autoDetectFloor(){
      if(!state.roomImage){ tip('Upload a room photo first.'); return; }
      const W = roomCanvas.width, H = roomCanvas.height;
      const maxW = 480; const sc = Math.min(1, maxW/W);
      const sw = Math.max(64, Math.round(W*sc));
      const sh = Math.max(64, Math.round(H*sc));
      const c = document.createElement('canvas'); c.width = sw; c.height = sh;
      const cx = c.getContext('2d');
      cx.drawImage(roomCanvas, 0, 0, sw, sh);
      const img = cx.getImageData(0,0,sw,sh); const d = img.data;
      const gray = new Float32Array(sw*sh);
      for (let i=0,j=0;i<d.length;i+=4,j++) gray[j] = d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114;
      const mag = new Float32Array(sw*sh);
      for (let y=1;y<sh-1;y++){
        for (let x=1;x<sw-1;x++){
          const i0=(y-1)*sw+(x-1), i1=(y-1)*sw+x, i2=(y-1)*sw+(x+1);
          const i3= y   *sw+(x-1), i5= y   *sw+(x+1);
          const i6=(y+1)*sw+(x-1), i7=(y+1)*sw+x, i8=(y+1)*sw+(x+1);
          const gx = -gray[i0] + gray[i2] - 2*gray[i3] + 2*gray[i5] - gray[i6] + gray[i8];
          const gy =  gray[i0] + 2*gray[i1] + gray[i2] - gray[i6] - 2*gray[i7] - gray[i8];
          mag[y*sw+x] = Math.abs(gx) + Math.abs(gy);
        }
      }
      const yStart = Math.floor(sh*0.35), yEnd = Math.floor(sh*0.9);
      const row = new Float32Array(sh);
      for(let y=yStart;y<yEnd;y++){ let s=0; for(let x=0;x<sw;x++) s+=mag[y*sw+x]; row[y]=s/sw; }
      let yTop=yStart, best=-1; for(let y=yStart;y<yEnd;y++){ if(row[y]>best){ best=row[y]; yTop=y; } }
      const tl={x:0.2,y:(yTop/sc)/H}, tr={x:0.8,y:(yTop/sc)/H}, bl={x:0.1,y:0.95}, br={x:0.9,y:0.95};
      state.quad=[tl,tr,br,bl]; updateMesh(); render(); syncHandles();
      tip('Basic auto-detect done. For best results, use “Detect & Replace (AI)”.');
    }

    const handles = [0,1,2,3].map(i=> $('h'+i));
    function syncHandles(){ for(let i=0;i<4;i++){ const p=state.quad[i]; handles[i].style.left=(p.x*100)+'%'; handles[i].style.top=(p.y*100)+'%'; } }
    handles.forEach((el,i)=>{
      let dragging=false;
      el.addEventListener('pointerdown', e=>{ dragging=true; el.setPointerCapture(e.pointerId); el.style.cursor='grabbing'; });
      el.addEventListener('pointerup',   e=>{ dragging=false; el.releasePointerCapture(e.pointerId); el.style.cursor='grab'; });
      el.addEventListener('pointermove', e=>{ if(!dragging) return; const r = glCanvas.getBoundingClientRect(); const x = (e.clientX - r.left) / r.width; const y = (e.clientY - r.top)  / r.height; state.quad[i] = { x: Math.max(0,Math.min(1,x)), y: Math.max(0,Math.min(1,y)) }; updateMesh(); render(); syncHandles(); });
    });

    const USE_REMOTE = true;
    const API_ENDPOINT = '/.netlify/functions/floor-chat';

    async function callRemote(userText){
      if (!USE_REMOTE) { tip('Remote AI is OFF'); return; }
      if (!state.roomImage) { tip('Upload a room photo first'); return; }
      busy(true);
      try{
        const roomImageDataURL = await roomToDataURL();
        const payload = {
          messages: [{ role:'user', content: userText || 'Detect the floor and replace with the provided plank texture.' }],
          roomImageDataURL,
          textureUrl: state.currentTextureUrl || ''
        };
        const resp = await fetch(API_ENDPOINT, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        if (!resp.ok){ const t = await resp.text(); throw new Error('HTTP '+resp.status+': '+t); }
        const data = await resp.json();
        if (Array.isArray(data.actions)) data.actions.forEach(runAction);
        if (data.text) tip(data.text);
      } catch(e){
        console.error(e); tip('AI error: ' + (e.message||String(e)));
        logDebug('AI fetch failed: '+(e.message||e));
      } finally {
        busy(false);
      }
    }

    function roomToDataURL(){
      return new Promise((resolve)=>{
        const c=document.createElement('canvas');
        c.width = state.roomImage.naturalWidth||state.roomImage.width;
        c.height= state.roomImage.naturalHeight||state.roomImage.height;
        const cx=c.getContext('2d');
        cx.drawImage(state.roomImage,0,0,c.width,c.height);
        resolve(c.toDataURL('image/jpeg',0.92));
      });
    }

    function runAction(action){
      if(!action || action.name!=='apply_floor_config') return;
      const a = action.arguments || {};
      if (Array.isArray(a.floorQuad) && a.floorQuad.length>=4){
        state.quad = a.floorQuad.slice(0,4).map(p=>({ x: clamp01(Number(p.x)), y: clamp01(Number(p.y)) }));
        syncHandles(); updateMesh();
      }
      if (a.orientation) state.orientation = (a.orientation==='vertical')?'vertical':'horizontal';
      if (num(a.rotationDegrees)) state.rotationDeg = a.rotationDegrees;
      if (num(a.scale)) state.scale = a.scale;
      if (num(a.randomness)) state.randomness = clamp01(a.randomness);
      if (a.textureUrl){ state.currentTextureUrl = String(a.textureUrl); setPlankFromURL(state.currentTextureUrl); }
      if (a.exportImage) exportPNG();
      render();
    }
    const num = (v)=> typeof v==='number' && isFinite(v);
    const clamp01 = (x)=> Math.max(0, Math.min(1, x));

    roomFile.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f){ logDebug('No file selected.'); return; }
      try{
        const img = await loadImage(f);
        state.roomImage = img;
        drawRoom(); updateMesh(); render();
        logDebug('');
      }catch(err){
        logDebug((err && err.message) || String(err));
      }
    });
    texFile.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f){ logDebug('No texture selected.'); return; }
      try{
        const img = await loadImage(f);
        setPlankFromImage(img);
        logDebug('');
      }catch(err){
        logDebug((err && err.message) || String(err));
      }
    });
    btnLoadURL.addEventListener('click', ()=>{
      const u=texUrl.value.trim();
      if(!u){ tip('Enter a texture URL'); return; }
      state.currentTextureUrl = u;
      setPlankFromURL(u);
    });

    btnH.addEventListener('click', ()=>{ state.orientation='horizontal'; updateMesh(); render(); });
    btnV.addEventListener('click', ()=>{ state.orientation='vertical';   updateMesh(); render(); });
    scaleEl.addEventListener('input', ()=>{ const v=Number(scaleEl.value); scaleVal.textContent=v.toFixed(2); state.scale=v; updateMesh(); render(); });
    rotationEl.addEventListener('input', ()=>{ const v=Number(rotationEl.value); rotVal.textContent=v.toFixed(1)+'°'; state.rotationDeg=v; updateMesh(); render(); });
    randomnessEl.addEventListener('input', ()=>{ const v=Number(randomnessEl.value); rndVal.textContent=v.toFixed(2); state.randomness=v; updateMesh(); render(); });
    grooveEl.addEventListener('input', ()=>{ const v=Number(grooveEl.value); grooveVal.textContent=v.toFixed(3); state.groove=v; render(); });
    lightEl.addEventListener('input',  ()=>{ const v=Number(lightEl.value); lightVal.textContent=v.toFixed(2); state.lightStrength=v; render(); });

    btnAuto.addEventListener('click', autoDetectFloor);
    btnAI.addEventListener('click', ()=> callRemote($('prompt').value.trim()));
    btnExport.addEventListener('click', exportPNG);

    document.getElementById('btnSelfTest').addEventListener('click', ()=>{
      const test = document.createElement('canvas'); test.width = 1024; test.height = 768;
      const tctx = test.getContext('2d');
      tctx.fillStyle = '#e9edf7'; tctx.fillRect(0,0,1024,480);
      tctx.fillStyle = '#b99774'; tctx.fillRect(0,480,1024,288);
      const img = new Image();
      img.onload=()=>{ state.roomImage=img; drawRoom(); updateMesh(); render(); logDebug('Self-test: demo room drawn. Now add a plank texture file to verify tiling.'); };
      img.src = test.toDataURL('image/png');
    });

    function ensureReady(){ resize(); logDebug('Boot ✓\nWebGL: '+(gl?'yes':'no')+'\nCanvas: '+glCanvas.width+'×'+glCanvas.height); }
    if (document.readyState === 'complete' || document.readyState === 'interactive'){
      setTimeout(ensureReady, 0);
    } else {
      window.addEventListener('DOMContentLoaded', ensureReady);
    }
  })();
  </script>
</body>
</html>
